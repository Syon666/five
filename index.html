<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>äº”å­æ£‹å®æ—¶å¯¹æˆ˜ - å®Œå…¨å…è´¹</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            -webkit-tap-highlight-color: transparent;
        }
        
        body {
            font-family: 'PingFang SC', 'Microsoft YaHei', sans-serif;
            background: linear-gradient(135deg, #6a11cb 0%, #2575fc 100%);
            min-height: 100vh;
            padding: 20px;
            display: flex;
            justify-content: center;
            align-items: center;
        }
        
        .game-container {
            width: 100%;
            max-width: 500px;
            background: white;
            border-radius: 20px;
            overflow: hidden;
            box-shadow: 0 20px 40px rgba(0,0,0,0.2);
        }
        
        /* è¿æ¥é¢æ¿ */
        .connection-panel {
            padding: 20px;
            background: #2c3e50;
            color: white;
            text-align: center;
        }
        
        .connection-panel h2 {
            margin-bottom: 20px;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 10px;
        }
        
        .connection-status {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 10px;
            margin: 15px 0;
            padding: 10px;
            border-radius: 10px;
            background: rgba(255,255,255,0.1);
        }
        
        .status-indicator {
            width: 12px;
            height: 12px;
            border-radius: 50%;
        }
        
        .status-connected {
            background: #2ecc71;
            box-shadow: 0 0 10px #2ecc71;
        }
        
        .status-disconnected {
            background: #e74c3c;
        }
        
        .status-connecting {
            background: #f39c12;
            animation: pulse 1.5s infinite;
        }
        
        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }
        
        .peer-id {
            background: rgba(255,255,255,0.1);
            padding: 10px 15px;
            border-radius: 10px;
            font-family: monospace;
            margin: 10px 0;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .copy-btn {
            background: #3498db;
            border: none;
            color: white;
            padding: 5px 10px;
            border-radius: 5px;
            cursor: pointer;
            transition: all 0.3s;
        }
        
        .copy-btn:hover {
            background: #2980b9;
        }
        
        .connection-controls {
            display: flex;
            gap: 10px;
            margin-top: 20px;
        }
        
        .connection-controls input {
            flex: 1;
            padding: 12px;
            border: 2px solid #3498db;
            border-radius: 10px;
            font-size: 16px;
        }
        
        .connection-controls button {
            padding: 12px 20px;
            background: #2ecc71;
            color: white;
            border: none;
            border-radius: 10px;
            cursor: pointer;
            font-size: 16px;
            font-weight: bold;
            transition: all 0.3s;
        }
        
        .connection-controls button:hover {
            background: #27ae60;
            transform: translateY(-2px);
        }
        
        .connection-controls button:disabled {
            background: #95a5a6;
            cursor: not-allowed;
            transform: none;
        }
        
        /* æ¸¸æˆé¢æ¿ */
        .game-panel {
            padding: 20px;
        }
        
        .game-info {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
            padding: 15px;
            background: #f8f9fa;
            border-radius: 10px;
        }
        
        .current-player {
            display: flex;
            align-items: center;
            gap: 10px;
            font-size: 18px;
            font-weight: bold;
        }
        
        .player-icon {
            width: 30px;
            height: 30px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-weight: bold;
        }
        
        .black-icon {
            background: #2c3e50;
        }
        
        .white-icon {
            background: white;
            color: #2c3e50 !important;
            border: 2px solid #bdc3c7;
        }
        
        .turn-info {
            font-size: 14px;
            color: #666;
        }
        
        /* æ£‹ç›˜ */
        .board-container {
            display: flex;
            justify-content: center;
            padding: 15px;
            background: #deab70;
            border-radius: 10px;
            margin-bottom: 15px;
        }
        
        #gameCanvas {
            background: #e0a75e;
            border-radius: 8px;
            box-shadow: 0 5px 15px rgba(0,0,0,0.2);
        }
        
        /* æ§åˆ¶æŒ‰é’® */
        .game-controls {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 10px;
        }
        
        .game-btn {
            padding: 15px;
            border: none;
            border-radius: 10px;
            font-size: 16px;
            font-weight: bold;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            transition: all 0.3s;
        }
        
        .game-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 10px rgba(0,0,0,0.1);
        }
        
        .btn-restart {
            background: #3498db;
            color: white;
        }
        
        .btn-undo {
            background: #9b59b6;
            color: white;
        }
        
        .btn-hint {
            background: #2ecc71;
            color: white;
        }
        
        .btn-quit {
            background: #e74c3c;
            color: white;
        }
        
        /* èŠå¤©é¢æ¿ */
        .chat-panel {
            border-top: 2px solid #eee;
            padding: 15px;
            background: #f8f9fa;
        }
        
        .chat-messages {
            height: 150px;
            overflow-y: auto;
            margin-bottom: 10px;
            padding: 10px;
            background: white;
            border-radius: 10px;
            border: 1px solid #ddd;
        }
        
        .chat-message {
            margin-bottom: 8px;
            padding: 8px 12px;
            border-radius: 10px;
            max-width: 80%;
        }
        
        .message-own {
            background: #3498db;
            color: white;
            margin-left: auto;
        }
        
        .message-other {
            background: #ecf0f1;
            color: #333;
            margin-right: auto;
        }
        
        .chat-input {
            display: flex;
            gap: 10px;
        }
        
        .chat-input input {
            flex: 1;
            padding: 12px;
            border: 2px solid #3498db;
            border-radius: 10px;
            font-size: 16px;
        }
        
        .chat-input button {
            padding: 12px 20px;
            background: #3498db;
            color: white;
            border: none;
            border-radius: 10px;
            cursor: pointer;
        }
        
        /* å“åº”å¼è®¾è®¡ */
        @media (max-width: 600px) {
            body {
                padding: 10px;
            }
            
            .game-container {
                border-radius: 15px;
            }
            
            .connection-controls {
                flex-direction: column;
            }
            
            .game-controls {
                grid-template-columns: 1fr;
            }
            
            .game-btn {
                padding: 12px;
            }
        }
    </style>
</head>
<body>
    <div class="game-container">
        <!-- è¿æ¥é¢æ¿ -->
        <div class="connection-panel" id="connectionPanel">
            <h2><i class="fas fa-users"></i> äº”å­æ£‹å®æ—¶å¯¹æˆ˜</h2>
            
            <div class="connection-status">
                <div class="status-indicator status-disconnected" id="statusIndicator"></div>
                <span id="statusText">ç­‰å¾…è¿æ¥...</span>
            </div>
            
            <div class="peer-id">
                <span>ä½ çš„ID: <span id="myPeerId">ç”Ÿæˆä¸­...</span></span>
                <button class="copy-btn" onclick="copyMyId()">
                    <i class="fas fa-copy"></i> å¤åˆ¶
                </button>
            </div>
            
            <div class="connection-controls">
                <input type="text" id="remotePeerId" placeholder="è¾“å…¥æœ‹å‹çš„IDè¿›è¡Œè¿æ¥">
                <button id="connectBtn" onclick="connectToPeer()">
                    <i class="fas fa-plug"></i> è¿æ¥æœ‹å‹
                </button>
            </div>
            
            <p style="margin-top: 15px; font-size: 14px; opacity: 0.8;">
                <i class="fas fa-info-circle"></i> å…ˆå¤åˆ¶ä½ çš„IDå‘ç»™æœ‹å‹ï¼Œæˆ–è€…è¾“å…¥æœ‹å‹çš„IDè¿›è¡Œè¿æ¥
            </p>
        </div>
        
        <!-- æ¸¸æˆé¢æ¿ -->
        <div class="game-panel" id="gamePanel" style="display: none;">
            <div class="game-info">
                <div class="current-player">
                    <div class="player-icon black-icon" id="playerIcon">
                        <i class="fas fa-chess-pawn"></i>
                    </div>
                    <span id="currentPlayerText">ç­‰å¾…å¼€å§‹...</span>
                </div>
                <div class="turn-info">
                    å›åˆ: <span id="turnCount">0</span> | 
                    ç©å®¶: <span id="playerRole">ç­‰å¾…åˆ†é…...</span>
                </div>
            </div>
            
            <div class="board-container">
                <canvas id="gameCanvas" width="450" height="450"></canvas>
            </div>
            
            <div class="game-controls">
                <button class="game-btn btn-restart" onclick="restartGame()">
                    <i class="fas fa-redo"></i> é‡æ–°å¼€å§‹
                </button>
                <button class="game-btn btn-undo" onclick="undoMove()">
                    <i class="fas fa-undo"></i> æ‚”æ£‹
                </button>
                <button class="game-btn btn-hint" onclick="showHint()">
                    <i class="fas fa-lightbulb"></i> æç¤º
                </button>
                <button class="game-btn btn-quit" onclick="quitGame()">
                    <i class="fas fa-sign-out-alt"></i> é€€å‡ºæˆ¿é—´
                </button>
            </div>
            
            <!-- èŠå¤©åŠŸèƒ½ -->
            <div class="chat-panel">
                <div class="chat-messages" id="chatMessages"></div>
                <div class="chat-input">
                    <input type="text" id="chatInput" placeholder="è¾“å…¥æ¶ˆæ¯...">
                    <button onclick="sendMessage()">
                        <i class="fas fa-paper-plane"></i> å‘é€
                    </button>
                </div>
            </div>
        </div>
    </div>

    <!-- PeerJSåº“ -->
    <script src="https://unpkg.com/peerjs@1.4.7/dist/peerjs.min.js"></script>

    <script>
        // ============ æ¸¸æˆé…ç½® ============
        const BOARD_SIZE = 15;
        const GRID_SIZE = 30;
        const MARGIN = 15;
        const CANVAS_SIZE = GRID_SIZE * (BOARD_SIZE - 1) + MARGIN * 2;
        
        // ============ æ¸¸æˆçŠ¶æ€ ============
        let board = Array(BOARD_SIZE).fill().map(() => Array(BOARD_SIZE).fill(0));
        let currentPlayer = 1; // 1:é»‘æ£‹, 2:ç™½æ£‹
        let gameOver = false;
        let moveHistory = [];
        let turnCount = 1;
        let myRole = null; // 'host' æˆ– 'guest'
        let isMyTurn = false;
        
        // ============ PeerJSè¿æ¥çŠ¶æ€ ============
        let peer = null;
        let conn = null;
        let myPeerId = null;
        let remotePeerId = null;
        let isConnected = false;
        
        // ============ DOMå…ƒç´  ============
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const connectionPanel = document.getElementById('connectionPanel');
        const gamePanel = document.getElementById('gamePanel');
        const statusIndicator = document.getElementById('statusIndicator');
        const statusText = document.getElementById('statusText');
        const myPeerIdElement = document.getElementById('myPeerId');
        
        // ============ åˆå§‹åŒ–PeerJS ============
        function initPeer() {
            updateStatus('æ­£åœ¨åˆå§‹åŒ–è¿æ¥...', 'connecting');
            
            // ä½¿ç”¨PeerJSçš„å…è´¹å…¬å…±æœåŠ¡å™¨
            peer = new Peer({
                host: '0.peerjs.com',
                port: 443,
                path: '/',
                debug: 3
            });
            
            // æˆåŠŸè·å–ID
            peer.on('open', (id) => {
                myPeerId = id;
                myPeerIdElement.textContent = id;
                updateStatus('å‡†å¤‡å°±ç»ªï¼Œç­‰å¾…è¿æ¥', 'disconnected');
                
                // ç›‘å¬å…¶ä»–ç©å®¶çš„è¿æ¥
                peer.on('connection', (connection) => {
                    handleIncomingConnection(connection);
                });
            });
            
            // è¿æ¥é”™è¯¯å¤„ç†
            peer.on('error', (err) => {
                console.error('PeerJSé”™è¯¯:', err);
                if (err.type === 'unavailable-id') {
                    // å¦‚æœIDè¢«å ç”¨ï¼Œç”Ÿæˆæ–°çš„
                    peer.destroy();
                    setTimeout(initPeer, 1000);
                } else {
                    updateStatus('è¿æ¥å¤±è´¥ï¼Œè¯·åˆ·æ–°é¡µé¢é‡è¯•', 'disconnected');
                }
            });
            
            // è¿æ¥æ–­å¼€
            peer.on('disconnected', () => {
                updateStatus('è¿æ¥å·²æ–­å¼€', 'disconnected');
                isConnected = false;
                showGamePanel(false);
            });
        }
        
        // ============ å¤„ç†ä¼ å…¥è¿æ¥ ============
        function handleIncomingConnection(connection) {
            if (conn) {
                // å·²ç»æœ‰è¿æ¥äº†ï¼Œæ‹’ç»æ–°çš„è¿æ¥
                connection.close();
                return;
            }
            
            conn = connection;
            remotePeerId = connection.peer;
            isConnected = true;
            myRole = 'host'; // å…ˆè¿æ¥çš„æ˜¯ä¸»æœº
            isMyTurn = true; // ä¸»æœºå…ˆæ‰‹
            
            setupConnectionHandlers();
            updateStatus(`å·²è¿æ¥: ${remotePeerId.substring(0, 8)}...`, 'connected');
            showGamePanel(true);
            
            // å‘é€æ¸¸æˆå¼€å§‹æ¶ˆæ¯
            sendGameMessage({
                type: 'game_start',
                role: 'guest',
                currentPlayer: 1
            });
            
            startGame();
        }
        
        // ============ ä¸»åŠ¨è¿æ¥å…¶ä»–ç©å®¶ ============
        function connectToPeer() {
            const remoteId = document.getElementById('remotePeerId').value.trim();
            
            if (!remoteId) {
                alert('è¯·è¾“å…¥æœ‹å‹çš„ID');
                return;
            }
            
            if (remoteId === myPeerId) {
                alert('ä¸èƒ½è¿æ¥è‡ªå·±ï¼');
                return;
            }
            
            updateStatus('æ­£åœ¨è¿æ¥...', 'connecting');
            
            // åˆ›å»ºè¿æ¥
            conn = peer.connect(remoteId, {
                reliable: true
            });
            
            if (!conn) {
                updateStatus('è¿æ¥å¤±è´¥', 'disconnected');
                return;
            }
            
            remotePeerId = remoteId;
            
            conn.on('open', () => {
                isConnected = true;
                myRole = 'guest'; // åè¿æ¥çš„æ˜¯å®¢æœº
                isMyTurn = false; // å®¢æœºåæ‰‹
                
                setupConnectionHandlers();
                updateStatus(`å·²è¿æ¥åˆ°: ${remoteId.substring(0, 8)}...`, 'connected');
                showGamePanel(true);
                
                // è¯·æ±‚åŠ å…¥æ¸¸æˆ
                sendGameMessage({
                    type: 'join_request'
                });
            });
            
            conn.on('error', (err) => {
                console.error('è¿æ¥é”™è¯¯:', err);
                updateStatus('è¿æ¥å¤±è´¥', 'disconnected');
                conn = null;
            });
        }
        
        // ============ è®¾ç½®è¿æ¥å¤„ç†å™¨ ============
        function setupConnectionHandlers() {
            conn.on('data', (data) => {
                handleGameMessage(data);
            });
            
            conn.on('close', () => {
                updateStatus('æœ‹å‹å·²æ–­å¼€è¿æ¥', 'disconnected');
                isConnected = false;
                conn = null;
                alert('æœ‹å‹å·²æ–­å¼€è¿æ¥ï¼Œæ¸¸æˆç»“æŸ');
                showGamePanel(false);
            });
            
            conn.on('error', (err) => {
                console.error('è¿æ¥é”™è¯¯:', err);
                updateStatus('è¿æ¥å‡ºé”™', 'disconnected');
            });
        }
        
        // ============ å¤„ç†æ¸¸æˆæ¶ˆæ¯ ============
        function handleGameMessage(data) {
            switch (data.type) {
                case 'join_request':
                    // å¯¹æ–¹è¯·æ±‚åŠ å…¥æ¸¸æˆ
                    sendGameMessage({
                        type: 'game_start',
                        role: 'guest',
                        currentPlayer: 1
                    });
                    startGame();
                    break;
                    
                case 'game_start':
                    // æ¸¸æˆå¼€å§‹
                    myRole = data.role;
                    isMyTurn = data.role === 'host'; // ä¸»æœºå…ˆæ‰‹
                    startGame();
                    break;
                    
                case 'move':
                    // å¯¹æ–¹è½å­
                    receiveMove(data.row, data.col, data.player);
                    break;
                    
                case 'undo_request':
                    // å¯¹æ–¹è¯·æ±‚æ‚”æ£‹
                    if (confirm('å¯¹æ–¹è¯·æ±‚æ‚”æ£‹ï¼Œæ˜¯å¦åŒæ„ï¼Ÿ')) {
                        undoLastMove();
                        sendGameMessage({
                            type: 'undo_approved'
                        });
                    } else {
                        sendGameMessage({
                            type: 'undo_denied'
                        });
                    }
                    break;
                    
                case 'undo_approved':
                    // å¯¹æ–¹åŒæ„æ‚”æ£‹
                    undoLastMove();
                    alert('å¯¹æ–¹åŒæ„æ‚”æ£‹');
                    break;
                    
                case 'undo_denied':
                    // å¯¹æ–¹æ‹’ç»æ‚”æ£‹
                    alert('å¯¹æ–¹æ‹’ç»æ‚”æ£‹');
                    break;
                    
                case 'restart':
                    // é‡æ–°å¼€å§‹æ¸¸æˆ
                    restartGame();
                    break;
                    
                case 'chat':
                    // èŠå¤©æ¶ˆæ¯
                    addChatMessage(data.message, 'other');
                    break;
                    
                case 'game_over':
                    // æ¸¸æˆç»“æŸ
                    gameOver = true;
                    showWinner(data.winner);
                    break;
            }
        }
        
        // ============ å‘é€æ¸¸æˆæ¶ˆæ¯ ============
        function sendGameMessage(data) {
            if (conn && conn.open) {
                conn.send(data);
            }
        }
        
        // ============ æ›´æ–°çŠ¶æ€æ˜¾ç¤º ============
        function updateStatus(text, status) {
            statusText.textContent = text;
            
            // ç§»é™¤æ‰€æœ‰çŠ¶æ€ç±»
            statusIndicator.className = 'status-indicator';
            
            // æ·»åŠ å½“å‰çŠ¶æ€ç±»
            switch (status) {
                case 'connected':
                    statusIndicator.classList.add('status-connected');
                    break;
                case 'disconnected':
                    statusIndicator.classList.add('status-disconnected');
                    break;
                case 'connecting':
                    statusIndicator.classList.add('status-connecting');
                    break;
            }
        }
        
        // ============ æ˜¾ç¤º/éšè—æ¸¸æˆé¢æ¿ ============
        function showGamePanel(show) {
            if (show) {
                connectionPanel.style.display = 'none';
                gamePanel.style.display = 'block';
                initGame();
            } else {
                connectionPanel.style.display = 'block';
                gamePanel.style.display = 'none';
            }
        }
        
        // ============ å¤åˆ¶æˆ‘çš„ID ============
        function copyMyId() {
            if (!myPeerId) {
                alert('IDç”Ÿæˆä¸­ï¼Œè¯·ç¨å€™...');
                return;
            }
            
            navigator.clipboard.writeText(myPeerId).then(() => {
                alert('IDå·²å¤åˆ¶åˆ°å‰ªè´´æ¿ï¼\n\nå‘é€ç»™ä½ çš„æœ‹å‹ï¼Œè®©ä»–è¾“å…¥è¿™ä¸ªIDè¿›è¡Œè¿æ¥ã€‚');
            }).catch(() => {
                // å¤‡ç”¨æ–¹æ¡ˆ
                const input = document.createElement('input');
                input.value = myPeerId;
                document.body.appendChild(input);
                input.select();
                document.execCommand('copy');
                document.body.removeChild(input);
                alert('IDå·²å¤åˆ¶ï¼');
            });
        }
        
        // ============ æ¸¸æˆé€»è¾‘å¼€å§‹ ============
        function initGame() {
            // è®¾ç½®Canvaså¤§å°
            canvas.width = CANVAS_SIZE;
            canvas.height = CANVAS_SIZE;
            
            // åˆå§‹åŒ–æ£‹ç›˜
            board = Array(BOARD_SIZE).fill().map(() => Array(BOARD_SIZE).fill(0));
            currentPlayer = 1;
            gameOver = false;
            moveHistory = [];
            turnCount = 1;
            
            // æ›´æ–°ç©å®¶è§’è‰²æ˜¾ç¤º
            document.getElementById('playerRole').textContent = 
                myRole === 'host' ? 'é»‘æ£‹(å…ˆæ‰‹)' : 'ç™½æ£‹(åæ‰‹)';
            
            // ç»˜åˆ¶æ£‹ç›˜
            drawBoard();
            updateGameInfo();
            
            // è®¾ç½®è§¦æ‘¸äº‹ä»¶
            setupTouchEvents();
        }
        
        function startGame() {
            initGame();
            
            // æ ¹æ®è§’è‰²è®¾ç½®åˆå§‹å›åˆ
            if (myRole === 'host') {
                isMyTurn = true;
                currentPlayer = 1;
                document.getElementById('currentPlayerText').textContent = 'ä½ çš„å›åˆ';
            } else {
                isMyTurn = false;
                currentPlayer = 1;
                document.getElementById('currentPlayerText').textContent = 'å¯¹æ–¹å›åˆ';
            }
            
            drawBoard();
            updateGameInfo();
        }
        
        // ============ ç»˜åˆ¶æ£‹ç›˜ ============
        function drawBoard() {
            // æ£‹ç›˜èƒŒæ™¯
            ctx.fillStyle = '#e0a75e';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // ç½‘æ ¼çº¿
            ctx.strokeStyle = '#8b4513';
            ctx.lineWidth = 1.5;
            
            for (let i = 0; i < BOARD_SIZE; i++) {
                // æ¨ªçº¿
                ctx.beginPath();
                ctx.moveTo(MARGIN, MARGIN + i * GRID_SIZE);
                ctx.lineTo(canvas.width - MARGIN, MARGIN + i * GRID_SIZE);
                ctx.stroke();
                
                // ç«–çº¿
                ctx.beginPath();
                ctx.moveTo(MARGIN + i * GRID_SIZE, MARGIN);
                ctx.lineTo(MARGIN + i * GRID_SIZE, canvas.height - MARGIN);
                ctx.stroke();
            }
            
            // æ˜Ÿä½
            const starPoints = [3, 7, 11];
            ctx.fillStyle = '#000';
            starPoints.forEach(x => {
                starPoints.forEach(y => {
                    ctx.beginPath();
                    ctx.arc(
                        MARGIN + x * GRID_SIZE,
                        MARGIN + y * GRID_SIZE,
                        4, 0, Math.PI * 2
                    );
                    ctx.fill();
                });
            });
            
            // æ£‹å­
            for (let row = 0; row < BOARD_SIZE; row++) {
                for (let col = 0; col < BOARD_SIZE; col++) {
                    if (board[row][col] === 1) {
                        drawPiece(col, row, '#000');
                    } else if (board[row][col] === 2) {
                        drawPiece(col, row, '#fff');
                    }
                }
            }
            
            // é«˜äº®æœ€åä¸€æ­¥
            if (moveHistory.length > 0) {
                const lastMove = moveHistory[moveHistory.length - 1];
                const x = MARGIN + lastMove.col * GRID_SIZE;
                const y = MARGIN + lastMove.row * GRID_SIZE;
                
                if (Date.now() % 1000 < 500) {
                    ctx.beginPath();
                    ctx.arc(x, y, 6, 0, Math.PI * 2);
                    ctx.fillStyle = '#ff4757';
                    ctx.fill();
                }
            }
        }
        
        function drawPiece(col, row, color) {
            const x = MARGIN + col * GRID_SIZE;
            const y = MARGIN + row * GRID_SIZE;
            const radius = GRID_SIZE * 0.4;
            
            // é˜´å½±
            ctx.beginPath();
            ctx.arc(x + 2, y + 2, radius, 0, Math.PI * 2);
            ctx.fillStyle = color === '#000' ? '#333' : '#eee';
            ctx.fill();
            
            // æ£‹å­
            ctx.beginPath();
            ctx.arc(x, y, radius, 0, Math.PI * 2);
            ctx.fillStyle = color;
            ctx.fill();
            
            // ç™½æ£‹è¾¹æ¡†
            if (color === '#fff') {
                ctx.strokeStyle = '#ccc';
                ctx.lineWidth = 1;
                ctx.stroke();
            }
        }
        
        // ============ è§¦æ‘¸äº‹ä»¶ ============
        function setupTouchEvents() {
            canvas.removeEventListener('click', handleClick);
            canvas.removeEventListener('touchstart', handleTouch);
            
            canvas.addEventListener('click', handleClick);
            canvas.addEventListener('touchstart', handleTouch, { passive: false });
        }
        
        function handleClick(e) {
            const rect = canvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;
            
            handleMove(x, y);
        }
        
        function handleTouch(e) {
            e.preventDefault();
            const rect = canvas.getBoundingClientRect();
            const touch = e.touches[0];
            const x = touch.clientX - rect.left;
            const y = touch.clientY - rect.top;
            
            handleMove(x, y);
        }
        
        function handleMove(x, y) {
            if (!isMyTurn || gameOver || !isConnected) return;
            
            const col = Math.round((x - MARGIN) / GRID_SIZE);
            const row = Math.round((y - MARGIN) / GRID_SIZE);
            
            if (row >= 0 && row < BOARD_SIZE && col >= 0 && col < BOARD_SIZE) {
                if (board[row][col] === 0) {
                    // æœ¬åœ°è½å­
                    makeMove(row, col, currentPlayer);
                    
                    // å‘é€ç»™å¯¹æ–¹
                    sendGameMessage({
                        type: 'move',
                        row: row,
                        col: col,
                        player: currentPlayer
                    });
                    
                    // æ£€æŸ¥èƒœè´Ÿ
                    if (checkWin(row, col, currentPlayer)) {
                        gameOver = true;
                        sendGameMessage({
                            type: 'game_over',
                            winner: currentPlayer
                        });
                        showWinner(currentPlayer);
                    } else {
                        // åˆ‡æ¢å›åˆ
                        currentPlayer = 3 - currentPlayer;
                        isMyTurn = false;
                        turnCount++;
                        
                        updateGameInfo();
                    }
                    
                    drawBoard();
                }
            }
        }
        
        function receiveMove(row, col, player) {
            makeMove(row, col, player);
            
            if (checkWin(row, col, player)) {
                gameOver = true;
                showWinner(player);
            } else {
                currentPlayer = 3 - player;
                isMyTurn = true;
                turnCount++;
                
                updateGameInfo();
            }
            
            drawBoard();
        }
        
        function makeMove(row, col, player) {
            board[row][col] = player;
            moveHistory.push({row, col, player});
        }
        
        // ============ æ¸¸æˆè§„åˆ™ ============
        function checkWin(row, col, player) {
            const directions = [
                [0,1], [1,0], [1,1], [1,-1]
            ];
            
            for (const [dx, dy] of directions) {
                let count = 1;
                
                let r = row + dx, c = col + dy;
                while (r >= 0 && r < BOARD_SIZE && c >= 0 && c < BOARD_SIZE && board[r][c] === player) {
                    count++;
                    r += dx;
                    c += dy;
                }
                
                r = row - dx, c = col - dy;
                while (r >= 0 && r < BOARD_SIZE && c >= 0 && c < BOARD_SIZE && board[r][c] === player) {
                    count++;
                    r -= dx;
                    c -= dy;
                }
                
                if (count >= 5) return true;
            }
            
            return false;
        }
        
        // ============ æ¸¸æˆæ§åˆ¶ ============
        function updateGameInfo() {
            document.getElementById('turnCount').textContent = turnCount;
            
            const playerIcon = document.getElementById('playerIcon');
            const playerText = document.getElementById('currentPlayerText');
            
            if (gameOver) {
                playerText.textContent = 'æ¸¸æˆç»“æŸ';
            } else if (isMyTurn) {
                playerIcon.className = `player-icon ${currentPlayer === 1 ? 'black-icon' : 'white-icon'}`;
                playerIcon.innerHTML = '<i class="fas fa-chess-pawn"></i>';
                playerText.textContent = 'ä½ çš„å›åˆ';
            } else {
                playerIcon.className = `player-icon ${currentPlayer === 1 ? 'black-icon' : 'white-icon'}`;
                playerIcon.innerHTML = '<i class="fas fa-chess-pawn"></i>';
                playerText.textContent = 'å¯¹æ–¹å›åˆ';
            }
        }
        
        function showWinner(winner) {
            const winnerName = winner === 1 ? 'é»‘æ£‹' : 'ç™½æ£‹';
            const iWon = (winner === 1 && myRole === 'host') || (winner === 2 && myRole === 'guest');
            
            if (iWon) {
                alert(`ğŸ‰ æ­å–œä½ è·èƒœï¼${winnerName}èƒœåˆ©ï¼`);
            } else {
                alert(`ğŸ¤ å¯¹æ–¹è·èƒœï¼${winnerName}èƒœåˆ©ï¼`);
            }
        }
        
        function restartGame() {
            if (!isConnected) {
                alert('æœªè¿æ¥ï¼Œæ— æ³•é‡æ–°å¼€å§‹');
                return;
            }
            
            if (confirm('ç¡®å®šè¦é‡æ–°å¼€å§‹æ¸¸æˆå—ï¼Ÿ')) {
                sendGameMessage({ type: 'restart' });
                startGame();
            }
        }
        
        function undoMove() {
            if (moveHistory.length === 0 || !isConnected) return;
            
            sendGameMessage({ type: 'undo_request' });
        }
        
        function undoLastMove() {
            if (moveHistory.length < 2) return;
            
            // ç§»é™¤æœ€åä¸¤æ­¥
            for (let i = 0; i < 2; i++) {
                if (moveHistory.length > 0) {
                    const move = moveHistory.pop();
                    board[move.row][move.col] = 0;
                }
            }
            
            turnCount = Math.max(1, turnCount - 1);
            isMyTurn = moveHistory.length % 2 === 0; // æ ¹æ®å†å²è®°å½•åˆ¤æ–­å›åˆ
            
            drawBoard();
            updateGameInfo();
        }
        
        function showHint() {
            alert('æç¤ºåŠŸèƒ½å¼€å‘ä¸­...');
        }
        
        function quitGame() {
            if (conn) {
                conn.close();
            }
            showGamePanel(false);
        }
        
        // ============ èŠå¤©åŠŸèƒ½ ============
        function sendMessage() {
            const input = document.getElementById('chatInput');
            const message = input.value.trim();
            
            if (!message) return;
            
            if (!isConnected) {
                alert('æœªè¿æ¥ï¼Œæ— æ³•å‘é€æ¶ˆæ¯');
                return;
            }
            
            // å‘é€ç»™å¯¹æ–¹
            sendGameMessage({
                type: 'chat',
                message: message
            });
            
            // æ˜¾ç¤ºè‡ªå·±çš„æ¶ˆæ¯
            addChatMessage(message, 'own');
            
            input.value = '';
        }
        
        function addChatMessage(message, type) {
            const chatMessages = document.getElementById('chatMessages');
            const messageDiv = document.createElement('div');
            
            messageDiv.className = `chat-message message-${type}`;
            messageDiv.textContent = message;
            
            chatMessages.appendChild(messageDiv);
            chatMessages.scrollTop = chatMessages.scrollHeight;
        }
        
        // ============ é¡µé¢åŠ è½½åˆå§‹åŒ– ============
        window.addEventListener('load', function() {
            initPeer();
            
            // ç›‘å¬å›è½¦é”®å‘é€æ¶ˆæ¯
            document.getElementById('chatInput').addEventListener('keypress', function(e) {
                if (e.key === 'Enter') {
                    sendMessage();
                }
            });
            
            // ç›‘å¬è¿æ¥è¾“å…¥æ¡†çš„å›è½¦é”®
            document.getElementById('remotePeerId').addEventListener('keypress', function(e) {
                if (e.key === 'Enter') {
                    connectToPeer();
                }
            });
        });
    </script>
</body>
</html>